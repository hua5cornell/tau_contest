\section{Buffer Insertion}

\begin{table*}
\caption{Impact of Incremental Design Changes}
\label{table:Change}
\centering
\begin{tabular}{|c|c|c|c|c|c|} \hline
Technique & Setup Timing & Hold Timing & Max Transition & Leakage Power & Area \\ \hline
Add Buffer & Degrade & Improve & Improve & Increase & Increase\\ \hline
Upsize Strength & Improve & Degrade & Improve & Increase & Increase \\ \hline
Downsize Strength & Degrade & Improve & Degrade & Decrease & Decrease \\ \hline
Delete Buffer & Degrade or Improve & Degrade or Improve & Degrade or Improve & Decrease & Decrease \\ \hline
\end{tabular}
\vspace{-1em}
\end{table*}

In this contest, we adopt the technique presented in~\cite{Shenoy:Minimum} to insert buffers to remove hold time constraints. We start by introducing the buffer insertion problem with some basic definitions in the paper.

A combinational circuit $C$ is represented as a directed acyclic graph, with set of vertices $V$ denoting every pin in the circuit and two sets of edges $E^{I}$ and $E^{E}$ denoting the two kinds of edges, internal and external. Specifically, an internal edge is directed from input pin of a gate to its output pin, and an external edge represents the interconnection or wiring in the circuit. An edge $e_{ij}$ from $i$ to $j$, where $i$ is called the fanin of $j$ and $j$ is called the fanout of $i$, has a weight $w_{ij}$ associated with it. If $e_{ij} \in E^{I}$, then the weight is the delay of the gate from the input represented by $i$ to the output of the gate. If $e_{ij} \in E^{E}$, then the weight is a variable whose value is to be determined. Delay can be inserted only on external edges. For each vertex $i$, $a_i$ denotes its early arrival time, $A_i$ denotes its late arrival time, $r_i$ denotes its early required time and $R_i$ denotes its late required time. Namely, $r_i \leq a_i \leq A_i \leq R_i$.

The buffer insertion problem can be stated as following: Given a circuit $C(V, E^{E} \cup E^{I})$ edge-weights on the internal edges, arrival times (early and late) at all primary input and the required time at all primary outputs, we assign a set of delays to the external edges so that all paths meet the hold time constraints. This is called the padding problem in the paper, and according to the paper, the following theorem gives a sufficient and necessary condition for the padding problem to have a feasible solution:
\begin{theorem}
In any circuit, let $i_1$ be a primary input and $i_n$ be a primary output such that there is a path $p$ from $i_1$ to $i_n$. The padding problem has a feasible solution if and only if for any such $p$, $A_{i1} - a_{i1} \leq R_{in} - r_{in}$.
\end{theorem}

According to the contest rule, buffers can be inserted an ideal wire, before the root of an RC-tree, or after the leaf of the RC-tree, but not within an RC-tree. In our implementation, we begin by an initial run of timing analysis for the circuit and identify those high fanout nets with the load capacitance larger than the maximum value that can be driven by the driver. Then, we insert the smallest buffer to these nets whose maximum driving capacitance is larger than or equal to the capacitance load.

After this high fanout nets pre-processing, we sort the hold slack value for all the paths and across multiple corners (since we are considering problems in multiple corners) and find the worst negative hold time slack value $s_h$ and its corresponding path p and corner. Then for all the edges on the path, we pick the one that has the largest setup time slack ($s_s$) (for the corresponding corner) and we will insert buffers at the leaf of the RC-Tree of the edge (wire) if there is any. To minimize the area and power, we will always insert the smallest buffer in the cell library. Since we can get the slew value of the edge (wire) from the timing analysis, and the capacitance value that the buffer is driving is also known, the two values are good approximations for the input slew and the output capacitance of the buffer, and we can use them to find the approximated delay value $d$ of the buffer. Assume that each of this buffer gives an approximated delay of $d$, the number of buffers we will insert is $\frac{\min\{|s_s|, |s_h|\}}{d}$. 


%\subsection{Buffer Insertion}
%%For buffer insertion problem, van Ginneken's algorithm~\cite{Lukas:Buffer} is considered to be a classic in the field. Given a fixed buffer tree and candidate buffer locations, it finds the optimal buffer solutions under Elmore delay models. Several papers extend the algorithm to handle library with multiple buffers, various kinds of constraints and delay models and wire sizing integration~\cite{Lillis:Optimal,Alpert:Wire,Alpert:Buffer,Lillis:Simultaneous,Cong:Buffer,Wong:A}. A significant limitation of van Ginneken's algorithm is that a fixed Steiner topology must be provided in advance. Several papers address the tree construction problems, including C-Tree Algorithm~\cite{Alpert:Buffered}, P-Tree Algorithm~\cite{Lillis:New} and S-Tree Algorithm~\cite{Hrkic:S}.
%
%In this contest, to minimize the area when inserting buffers, we only choose the smallest buffer available in the cell library. Also since we are considering the problem under multiple corners, we will choose the $\star$ worst corner to perform buffer insertion. Notice that this step is not aim to fix all the timing violations, but to just reduce the capacitance load of those high fan-out nets, and any remaining violations and optimization problems will be left to gate sizing section.
%
%We adopt the ideas presented in C-Tree Algorithm~\cite{Alpert:Buffered}, followed by van Ginneken's algorithm~\cite{Lukas:Buffer}. Since we are only going to insert buffers for high-fan-out nets without an RC-tree (which means ideal wires), we might want to modify the existing algorithm a little bit and we will not construct the specific steiner tree construction as described in~\cite{Alpert:Buffered}. We will start by performing 2-clustering, which separate the sinks with similar characteristics (criticality and capacitance) into two clusters recursively, from top to the bottom, until each cluster has no more than 2 sinks. This step essentially create a binary tree where each branching point is a potential position for a buffer. Then, the van Ginneken's algorithm~\cite{Lukas:Buffer} can be applied to determine the optimal buffer insertion solution for the given topology.
%
%Since the solution quality heavily depends on the initial topology we construct, we need to give a good clustering metric between pairs of points (sinks). Due to the ideal wire-model assumption of these nets for buffer insertion in this contest, our clustering metric is slightly different from that presented in~\cite{Lukas:Buffer}. In our implementation, sinks nodes are clustered based on the slack and the capacitance value. We adopt similar idea presented in the paper and the criticality distance between two sink nodes $s_i$ and $s_j$, $tDist(s_i, s_j) = |crit(s_i) - crit(s_j)|$ and
%\begin{equation}
%crit(s_i) = e^{\alpha(mAS - AS(s_i))/(aAS - mAS)}
%\end{equation}
%where $AS(s_i)$ is the slack of the sink node $s_i$, $mAS$ and $aAS$ are the minimum and the average slack for all the sinks, and $\alpha > 0$ is a user parameter. Since the buffers are inserted in an ideal wire in our problem, we also have $AS(s_i) = RAT(s_i)$, so are $mAS$ and $aAS$. Furthermore, our problem consider multiple corners, and we will just choose the corner which gives the worst slack for each sink so that the algorithm gives the buffer insertion solution under the worst case.
%
%The capacitance distance definition is different. Since we want to separate the two sinks whenever they lead to large total capacitance, a reasonable normalized capacitance distance definition between two sink nodes $s_i$ and $s_j$, $cDist(s_i, s_j)$ will be $|ncap(s_i) + ncap(s_j)|$, where
%\begin{equation}
%ncap(s_i) = \frac{cap(s_i)}{\Sigma_i cap(s_i)},
%\end{equation}
%The final distance $D(s_i, s_j)$ is simply defined as the summation of the two distances:
%\begin{equation}
%D(s_i, s_j) = tDist(s_i, s_j) + cDist(s_i, s_j).
%\end{equation}
%%we are going to use in clustering will be the Euclidean distance defined as:
%%\begin{equation}
%%D(s_i, s_j) = \sqrt{tDist(s_i, s_j)^2 + cDist(s_i, s_j)^2}.
%%\end{equation}




